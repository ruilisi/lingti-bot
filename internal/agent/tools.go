package agent

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"time"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/pltanton/lingti-bot/internal/logger"
	"github.com/pltanton/lingti-bot/internal/router"
	"github.com/pltanton/lingti-bot/internal/tools"
)

// executeSystemInfo runs the system_info tool
func executeSystemInfo(ctx context.Context) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{}

	result, err := tools.SystemInfo(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}

	return extractText(result)
}

// executeCalendarToday runs the calendar_today tool
func executeCalendarToday(ctx context.Context) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{}

	result, err := tools.CalendarToday(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}

	return extractText(result)
}

// executeCalendarListEvents runs the calendar_list_events tool
func executeCalendarListEvents(ctx context.Context, days int) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{
		"days": float64(days),
	}

	result, err := tools.CalendarListEvents(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}

	return extractText(result)
}

// executeFileSend validates a file path and returns a FileAttachment for sending to the user.
// It is handled specially in processToolCalls (not routed through callToolDirect).
func executeFileSend(input json.RawMessage) (string, *router.FileAttachment) {
	var args struct {
		Path      string `json:"path"`
		MediaType string `json:"media_type"`
	}
	if err := json.Unmarshal(input, &args); err != nil {
		return fmt.Sprintf("Error parsing arguments: %v", err), nil
	}
	if args.Path == "" {
		return "Error: path is required", nil
	}

	// Expand ~ to home directory
	path := args.Path
	if strings.HasPrefix(path, "~/") {
		home, _ := os.UserHomeDir()
		path = filepath.Join(home, path[2:])
	}

	// Verify file exists and is not a directory
	info, err := os.Stat(path)
	if err != nil {
		return fmt.Sprintf("Error: file not found: %s", path), nil
	}
	if info.IsDir() {
		return fmt.Sprintf("Error: %s is a directory, not a file", path), nil
	}

	mediaType := args.MediaType
	if mediaType == "" {
		mediaType = "file"
	}

	logger.Info("[Agent] file_send: queued %s (%s, %d bytes)", path, mediaType, info.Size())
	return fmt.Sprintf("File queued for sending: %s (%d bytes)", filepath.Base(path), info.Size()), &router.FileAttachment{
		Path:      path,
		Name:      filepath.Base(path),
		MediaType: mediaType,
	}
}

// executeFileList runs the file_list tool
func executeFileList(ctx context.Context, path string) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{
		"path": path,
	}

	result, err := tools.FileList(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}

	return extractText(result)
}

// executeFileListOld runs the file_list_old tool
func executeFileListOld(ctx context.Context, path string, days int) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{
		"path": path,
		"days": float64(days),
	}

	result, err := tools.FileListOld(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}

	return extractText(result)
}

// executeFileTrash moves files to trash
func executeFileTrash(ctx context.Context, args map[string]any) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = args

	result, err := tools.FileMoveToTrash(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}

	return extractText(result)
}

// executeFileRead reads a file
func executeFileRead(ctx context.Context, path string) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{
		"path": path,
	}

	result, err := tools.FileRead(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}

	return extractText(result)
}

// executeShell runs the shell_execute tool
func executeShell(ctx context.Context, command string) string {
	logger.Verbose("[Shell] Executing: %s", command)

	// Safety check
	blocked := []string{"rm -rf /", "mkfs", "dd if="}
	cmdLower := strings.ToLower(command)
	for _, b := range blocked {
		if strings.Contains(cmdLower, b) {
			logger.Verbose("[Shell] Command blocked for safety")
			return "Command blocked for safety"
		}
	}

	ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	cmd := exec.CommandContext(ctx, "sh", "-c", command)
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	err := cmd.Run()

	var result strings.Builder
	if stdout.Len() > 0 {
		result.WriteString(stdout.String())
	}
	if stderr.Len() > 0 {
		result.WriteString("\nstderr: " + stderr.String())
	}
	if err != nil {
		result.WriteString("\nerror: " + err.Error())
	}

	output := result.String()

	// Log result at verbose level (truncate if too long)
	if len(output) > 500 {
		logger.Verbose("[Shell] Output: %s... (truncated)", output[:500])
	} else {
		logger.Verbose("[Shell] Output: %s", output)
	}

	return output
}

// executeOpenURL opens a URL in the default browser
func executeOpenURL(ctx context.Context, url string) string {
	if url == "" {
		return "Error: URL is required"
	}

	// Validate URL has a scheme
	if !strings.HasPrefix(url, "http://") && !strings.HasPrefix(url, "https://") {
		url = "https://" + url
	}

	var cmd *exec.Cmd
	switch runtime.GOOS {
	case "darwin":
		cmd = exec.CommandContext(ctx, "open", url)
	case "windows":
		cmd = exec.CommandContext(ctx, "cmd", "/c", "start", url)
	default: // linux and others
		cmd = exec.CommandContext(ctx, "xdg-open", url)
	}

	err := cmd.Start()
	if err != nil {
		return "Error opening URL: " + err.Error()
	}

	return "Opened " + url + " in browser"
}

// extractText extracts text content from MCP result
func extractText(result *mcp.CallToolResult) string {
	if result == nil {
		return ""
	}

	for _, content := range result.Content {
		if textContent, ok := content.(mcp.TextContent); ok {
			return textContent.Text
		}
	}

	return ""
}

// === CALENDAR ===

func executeCalendarCreate(ctx context.Context, args map[string]any) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = args
	result, err := tools.CalendarCreateEvent(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeCalendarSearch(ctx context.Context, args map[string]any) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = args
	result, err := tools.CalendarSearchEvents(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeCalendarDelete(ctx context.Context, args map[string]any) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = args
	result, err := tools.CalendarDeleteEvent(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

// === REMINDERS ===

func executeRemindersToday(ctx context.Context) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{}
	result, err := tools.RemindersToday(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeRemindersAdd(ctx context.Context, args map[string]any) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = args
	result, err := tools.RemindersAdd(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeRemindersComplete(ctx context.Context, title string) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{"title": title}
	result, err := tools.RemindersComplete(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeRemindersDelete(ctx context.Context, title string) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{"title": title}
	result, err := tools.RemindersDelete(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

// === NOTES ===

func executeNotesList(ctx context.Context, args map[string]any) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = args
	result, err := tools.NotesListNotes(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeNotesRead(ctx context.Context, title string) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{"title": title}
	result, err := tools.NotesRead(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeNotesCreate(ctx context.Context, args map[string]any) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = args
	result, err := tools.NotesCreate(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeNotesSearch(ctx context.Context, keyword string) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{"keyword": keyword}
	result, err := tools.NotesSearch(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

// === WEATHER ===

func executeWeatherCurrent(ctx context.Context, location string) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{"location": location}
	result, err := tools.WeatherCurrent(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeWeatherForecast(ctx context.Context, location string, days int) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{"location": location, "days": float64(days)}
	result, err := tools.WeatherForecast(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

// === WEB ===

func executeWebSearch(ctx context.Context, query string) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{"query": query}
	result, err := tools.WebSearch(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeWebFetch(ctx context.Context, url string) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{"url": url}
	result, err := tools.WebFetch(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

// === BROWSER AUTOMATION ===

func executeBrowserNavigate(ctx context.Context, url string) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{"url": url}
	result, err := tools.BrowserNavigate(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeBrowserSnapshot(ctx context.Context) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{}
	result, err := tools.BrowserSnapshot(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeBrowserClick(ctx context.Context, ref int) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{"ref": float64(ref)}
	result, err := tools.BrowserClick(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeBrowserType(ctx context.Context, ref int, text string, submit bool) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{"ref": float64(ref), "text": text, "submit": submit}
	result, err := tools.BrowserType(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeBrowserPress(ctx context.Context, key string) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{"key": key}
	result, err := tools.BrowserPress(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeBrowserExecuteJS(ctx context.Context, script string) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{"script": script}
	result, err := tools.BrowserExecuteJS(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeBrowserScreenshot(ctx context.Context, args map[string]any) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = args
	result, err := tools.BrowserScreenshot(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeBrowserTabs(ctx context.Context) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{}
	result, err := tools.BrowserTabs(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeBrowserTabOpen(ctx context.Context, args map[string]any) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = args
	result, err := tools.BrowserTabOpen(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeBrowserTabClose(ctx context.Context, args map[string]any) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = args
	result, err := tools.BrowserTabClose(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeBrowserStatus(ctx context.Context) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{}
	result, err := tools.BrowserStatus(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeBrowserStop(ctx context.Context) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{}
	result, err := tools.BrowserStop(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

// === CLIPBOARD ===

func executeClipboardRead(ctx context.Context) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{}
	result, err := tools.ClipboardRead(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeClipboardWrite(ctx context.Context, content string) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{"content": content}
	result, err := tools.ClipboardWrite(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

// === NOTIFICATION ===

func executeNotificationSend(ctx context.Context, args map[string]any) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = args
	result, err := tools.NotificationSend(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

// === SCREENSHOT ===

func executeScreenshot(ctx context.Context, args map[string]any) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = args
	result, err := tools.ScreenshotCapture(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

// === MUSIC ===

func executeMusicPlay(ctx context.Context) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{}
	result, err := tools.MusicPlay(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeMusicPause(ctx context.Context) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{}
	result, err := tools.MusicPause(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeMusicNext(ctx context.Context) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{}
	result, err := tools.MusicNext(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeMusicPrevious(ctx context.Context) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{}
	result, err := tools.MusicPrevious(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeMusicNowPlaying(ctx context.Context) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{}
	result, err := tools.MusicNowPlaying(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeMusicVolume(ctx context.Context, volume float64) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{"volume": volume}
	result, err := tools.MusicSetVolume(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeMusicSearch(ctx context.Context, query string) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{"query": query}
	result, err := tools.MusicSearch(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

// === GIT ===

func executeGitStatus(ctx context.Context) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{}
	result, err := tools.GitStatus(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeGitLog(ctx context.Context, args map[string]any) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = args
	result, err := tools.GitLog(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeGitDiff(ctx context.Context, args map[string]any) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = args
	result, err := tools.GitDiff(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeGitBranch(ctx context.Context) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{}
	result, err := tools.GitBranch(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

// === GITHUB ===

func executeGitHubPRList(ctx context.Context, args map[string]any) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = args
	result, err := tools.GitHubPRList(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeGitHubPRView(ctx context.Context, args map[string]any) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = args
	result, err := tools.GitHubPRView(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeGitHubIssueList(ctx context.Context, args map[string]any) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = args
	result, err := tools.GitHubIssueList(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeGitHubIssueView(ctx context.Context, args map[string]any) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = args
	result, err := tools.GitHubIssueView(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeGitHubIssueCreate(ctx context.Context, args map[string]any) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = args
	result, err := tools.GitHubIssueCreate(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}

func executeGitHubRepoView(ctx context.Context) string {
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{}
	result, err := tools.GitHubRepoView(ctx, req)
	if err != nil {
		return "Error: " + err.Error()
	}
	return extractText(result)
}
